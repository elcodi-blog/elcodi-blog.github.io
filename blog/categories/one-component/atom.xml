<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: One Component | Elcodi blog]]></title>
  <link href="http://elcodi-blog.github.io/blog/categories/one-component/atom.xml" rel="self"/>
  <link href="http://elcodi-blog.github.io/"/>
  <updated>2014-11-18T22:47:07+01:00</updated>
  <id>http://elcodi-blog.github.io/</id>
  <author>
    <name><![CDATA[Elcodi Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Routing Component]]></title>
    <link href="http://elcodi-blog.github.io/blog/2014/11/18/the-routing-component/"/>
    <updated>2014-11-18T22:39:54+01:00</updated>
    <id>http://elcodi-blog.github.io/blog/2014/11/18/the-routing-component</id>
    <content type="html"><![CDATA[<p>As a complement to the <a href="http://mmoreram.com/blog/2014/08/07/symfony-walk-zaragoza-madrid/">#SymfonyWalk</a> we start <a href="http://mmoreram.com/blog/2014/08/12/one-section-one-component/">&ldquo;One section, one component&rdquo;</a>, a series of posts about some of the symfony components. Let&rsquo;s start with routing!</p>

<h2>Description</h2>

<p>As each component does, the <a href="https://github.com/symfony/Routing">Routing component</a> focuses and solves a small problem, in this case, matching urls to routes, so we can extract related information, and vice versa.</p>

<p>Things you can do with this component:
&ndash; Load your routes from anywhere into a collection.
&ndash; Check if a request matches any of the routes.
&ndash; Extract route-specific info from the request.
&ndash; Generate a url from a route and route specific info.</p>

<h2>Basic classes</h2>

<p>The cast of this component is:
&ndash; <strong><code>Route</code></strong>: definition of a route, with path, requirements, options and conditionsâ€¦
&ndash; <strong><code>RouteCollection</code></strong>: this bundles one or more <code>Routes</code> and allows to configure all of them at once.
&ndash; <strong><code>Matcher</code></strong>: Searches a <code>RouteCollection</code> for a matching uri.
&ndash; <strong><code>RequestContext</code></strong>: Context from the current request.</p>

<h2>Example of usage</h2>

<p>```php
$route = new Route(&lsquo;/{name}&rsquo;);
$route->setDefaults([</p>

<pre><code>'_controller' =&gt; 'GreeterController',
</code></pre>

<p>]);
$route->setRequirements([</p>

<pre><code>'name' =&gt; '[a-z]+',
</code></pre>

<p>]);</p>

<p>$routes = new RouteCollection();
$routes->add(&lsquo;greet&rsquo;, $route);
$routes->addPrefix(&lsquo;/hello&rsquo;);</p>

<p>$context = new RequestContext();
$matcher = new UrlMatcher($routes, $context);
$parameters = $matcher->match(&lsquo;/hello/fabien&rsquo;);</p>

<p>/<em>
 * $parameters === [
 *   &lsquo;<em>route&rsquo; => &lsquo;greet&rsquo;,
 *   &lsquo;</em>controller&rsquo; => &lsquo;GreeterController&rsquo;,
 *   &lsquo;name&rsquo; => &lsquo;fabien&rsquo;,
 * ]
 </em>/
```</p>

<h2>Other classes</h2>

<p>Other supporting actors:
&ndash; <strong>Loader</strong>: Loads a <code>RouteCollection</code> from a source.
&ndash; <strong>Generator</strong>: The opposite of <code>Matcher</code>, given a route name and route-specific information, generates the uri.
&ndash; <strong>Dumper</strong>: The opposite of <code>Loader</code>, dumps a <code>RouteCollection</code> in different formats.
&ndash; <strong>Router</strong>: basically a <a href="http://en.wikipedia.org/wiki/Facade_pattern">facade</a> to <code>Matcher</code> and <code>Generator</code>.</p>

<h2>In Symfony2 framework</h2>

<p>Symfony2 framework reads routes from routing files with this component, matches the current <code>Request</code> and chooses which <code>Controller</code> and action to run. It also extends the <code>Router</code> so you can use parameter placeholders from <a href="https://github.com/symfony/DependencyInjection"><code>DependencyInjection</code></a> and integrates with the <a href="https://github.com/symfony/Config"><code>Config</code></a> component to allow caching.</p>

<h2>In Elcodi</h2>

<p>In Elcodi, as a library, we try not to couple our very few controllers to a specific route and we leave that responsibility to the layers above. For more complex scenarios, like the <a href="https://github.com/elcodi/MediaBundle"><code>MediaBundle</code></a> and the forthcoming <a href="https://github.com/elcodi/elcodi/tree/ec8fabe99489ae9dd1ef671eefaaa7ac89e24cdb/src/Elcodi/Bundle/PageBundle"><code>PageBundle</code></a>, we implement our own custom <code>Loader</code> so we can route through them.</p>

<h2>Conclusion</h2>

<p>This component deals with the next step just after getting your <a href="http://symfony.com/doc/current/components/http_foundation">HTTP Request</a> and gives you great power and flexibility to split your application into several routes.</p>

<p>I hope you find this component useful!</p>

<h2>Urls</h2>

<ul>
<li><a href="https://github.com/symfony/Routing">Repository</a></li>
<li><a href="http://symfony.com/doc/current/components/routing">Documentation</a></li>
<li><a href="https://packagist.org/packages/symfony/routing">Packagist</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
